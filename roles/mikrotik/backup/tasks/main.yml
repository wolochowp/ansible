# SPDX-License-Identifier: MIT-0
---
# -----------------------------
# Validate variables and sshpass when needed
# -----------------------------
- name: Validate required variables
  ansible.builtin.fail:
    msg: "remote_backup_user and remote_backup_host must be defined"
  when: remote_backup_user is not defined or remote_backup_host is not defined

- name: Ensure sshpass is available if password-based auth is used
  when: remote_backup_password is defined
  ansible.builtin.stat:
    path: /usr/bin/sshpass
  register: sshpass_check
  delegate_to: localhost
  run_once: true

- name: Fail if sshpass is required but not found
  when: remote_backup_password is defined and not sshpass_check.stat.exists
  ansible.builtin.fail:
    msg: "Password-based authentication requires 'sshpass' to be installed on the Ansible controller."

# -----------------------------
# Setup facts about backup file
# -----------------------------
- name: Generate timestamp
  tags: [facts_setup]
  set_fact:
    backup_timestamp: "{{ lookup('pipe', 'date +%Y%m%d%H%M%S') }}"

- name: Define backup filename without extension
  tags: [facts_setup]
  set_fact:
    backup_filename: "{{ inventory_hostname }}.{{ backup_timestamp }}"

- name: Define backup file extension
  tags: [facts_setup]
  set_fact:
    backup_extension: "{{ 'backup' if backup_format == 'backup' else 'rsc' }}"

- name: Define full backup file name with extension
  tags: [facts_setup]
  set_fact:
    backup_full_filename: "{{ backup_filename }}.{{ backup_extension }}"

- name: Create backup file on MikroTik
  community.routeros.command:
    commands:
      - >-
        {% if backup_format == 'backup' %}
        /system/backup/save
        {% if encrypt_pass is defined %}
        password={{ encrypt_pass }}
        encryption=aes-sha256
        {% endif %}
        name={{ backup_filename }}
        {% else %}
        /export file={{ backup_filename }}
        {% endif %}
  register: backup_result

- name: Report backup creation
  ansible.builtin.debug:
    msg: "Backup file {{ backup_full_filename }} created on MikroTik."
  when: backup_result is defined and not backup_result.failed

# -----------------------------
# Direct Transfer (MikroTik → Remote)
# -----------------------------
- name: Upload backup file to remote destination (MikroTik push)
  when: direct_transfer | bool
  routeros_command:
    commands:
      - >-
        /tool fetch upload=yes mode=sftp ascii=no
        src-path="{{ backup_full_filename }}"
        dst-path="{{ remote_backup_path }}/{{ backup_full_filename }}"
        address={{ remote_backup_host }}
        port={{ remote_backup_port }}
        user={{ remote_backup_user }}
        {% if remote_backup_password is defined %}
        password={{ remote_backup_password }}
        {% endif %}
  register: direct_upload_result
  notify: Clean up backup file on MikroTik

- name: Report direct upload result
  when: direct_transfer | bool and direct_upload_result is defined
  ansible.builtin.debug:
    msg: "Backup uploaded directly from MikroTik to {{ remote_backup_host }} via SFTP."

# -----------------------------
# Indirect Transfer (MikroTik → Ansible → Remote)
# -----------------------------
- name: Fetch backup file from MikroTik to Ansible controller
  when: not direct_transfer | bool
  ansible.netcommon.net_get:
    src: "{{ backup_full_filename }}"
    dest: "{{ non_direct_transfer_tmp_path }}/{{ backup_full_filename }}"
  register: fetch_result
  notify: Clean up backup file on MikroTik

- name: Report fetch from MikroTik
  when: not direct_transfer | bool and fetch_result is defined
  ansible.builtin.debug:
    msg: "Backup {{ backup_full_filename }} fetched to {{ non_direct_transfer_tmp_path }} from MikroTik."

- name: Upload backup via SFTP (password or key-based auth)
  ansible.builtin.command:
    argv: >-
      {{
        (remote_backup_password is defined) 
        | ternary(
            [
              'sshpass', '-p', remote_backup_password,
              'sftp', '-oStrictHostKeyChecking=no', '-P', remote_backup_port|string,
              remote_backup_user ~ '@' ~ remote_backup_host
            ],
            [
              'sftp', '-oStrictHostKeyChecking=no', '-P', remote_backup_port|string,
              remote_backup_user ~ '@' ~ remote_backup_host
            ]
          )
      }}
    stdin: "put {{ non_direct_transfer_tmp_path }}/{{ backup_full_filename }} {{ remote_backup_path }}/{{ backup_full_filename }}"
  register: sftp_upload_result
  changed_when: sftp_upload_result.rc == 0
  notify: Remove temporary backup file on Ansible controller

- name: Report indirect SFTP upload result
  when: not direct_transfer | bool and sftp_upload_pw.rc == 0
  ansible.builtin.debug:
    msg: "Backup {{ backup_full_filename }} uploaded from Ansible to {{ remote_backup_host }}:{{ remote_backup_path }}"

